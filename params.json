{"body":"oogl.js\r\n=======\r\n\r\nA thin object-oriented layer above WebGL.\r\n\r\nOOGL provides an extended GL context that adds object-oriented features allowing you to make GL calls more easily while keeping maximum possible performance.\r\n\r\nOOGL is not another scene graph library: OOGL strongly focuses on performance and lets you do exactly what you would do in plain WebGL, just easier.\r\n\r\nSee the [OOGL API Reference](http://71104.github.com/oogl.js/doc/) and the [Demos](http://71104.github.com/oogl.js/demos/).\r\n\r\nGetting started\r\n===============\r\n\r\nTo get started with OOGL, include it using a `<script>` tag in the `<head>` of your document:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"oogl-1.0.0.min.js\"></script>\r\n```\r\n\r\nThen place a `<canvas>` in your DOM and create an OOGL context through JavaScript:\r\n\r\n```html\r\n<canvas id=\"canvas\" width=\"800\" height=\"600\">\r\n\t<p>No browser support.</p>\r\n</canvas>\r\n<script type=\"text/javascript\">\r\nOOGL(function () {\r\n\tvar oogl = new OOGL.Context('canvas');\r\n\r\n\t// example GL calls\r\n\toogl.clearColor(0, 0, 0, 1);\r\n\toogl.clear(oogl.COLOR_BUFFER_BIT);\r\n\toogl.flush();\r\n});\r\n</script>\r\n```\r\n\r\nThe `oogl` object now contains all the WebGL functions a normal `gl` object would contain, plus OOGL-specific features.\r\n\r\nThe first triangle\r\n==================\r\n\r\nDrawing with OOGL is easier than doing it with plain WebGL.\r\n\r\nLet's first create a pair of shaders. Here's the vertex one:\r\n\r\n```glsl\r\nattribute vec2 in_Vertex;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(in_Vertex, 0, 2);\r\n}\r\n```\r\n\r\nAnd the fragment one:\r\n\r\n```glsl\r\nprecision mediump float;\r\n\r\nvoid main() {\r\n\tgl_FragColor = vec4(1);\r\n}\r\n```\r\n\r\nAssume they are called `test.vert` and `test.frag`, respectively, and they are located in the same directory as the HTML page.\r\n\r\nThe OOGL calls needed to create a vertex array, load the shaders and make the drawing are as follows:\r\n\r\n```javascript\r\nOOGL(function () {\r\n\tvar oogl = new OOGL.Context('canvas');\r\n\toogl.clearColor(0, 0, 0, 1);\r\n\toogl.clear(oogl.COLOR_BUFFER_BIT);\r\n\tvar array = new oogl.AttributeArray2(0, 'float', [-1, 1, -1, -1, 1, -1]);\r\n\tarray.bindAndPointer();\r\n\tvar program = new oogl.AjaxProgram('test', ['in_Vertex'], function () {\r\n\t\tprogram.use();\r\n\t\toogl.drawArrays(oogl.TRIANGLES, 0, 3);\r\n\t\toogl.flush();\r\n\t});\r\n});\r\n```\r\n\r\nHere we use the `AjaxProgram` utility class to load the shader pair asynchronously. The constructed `AjaxProgram` object refers to the `test.vert` and `test.frag` files because of its `test` first argument; the `.vert` and `.frag` extensions are added automatically.\r\n\r\nThe last calls (`program.use()` through `oogl.flush()`) are made asynchronously in a callback function passed to the `AjaxProgram` constructor that is called after the shaders have been loaded and compiled and the program has been linked.\r\n\r\nShould you wish to apply per-vertex interpolated colors, you first modify the shaders as follows:\r\n\r\n```glsl\r\nattribute vec2 in_Vertex;\r\nattribute vec3 in_Color;\r\n\r\nvarying vec3 ex_Color;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(in_Vertex, 0, 2);\r\n\tex_Color = in_Color;\r\n}\r\n```\r\n\r\n```glsl\r\nprecision mediump float;\r\n\r\nvarying vec3 ex_Color;\r\n\r\nvoid main() {\r\n\tgl_FragColor = vec4(ex_Color, 1);\r\n}\r\n```\r\n\r\nAnd then use the `AttributeArrays` utility class in the JavaScript code:\r\n\r\n```javascript\r\nOOGL(function () {\r\n\tvar oogl = new OOGL.Context('canvas');\r\n\toogl.clearColor(0, 0, 0, 1);\r\n\toogl.clear(oogl.COLOR_BUFFER_BIT);\r\n\tvar arrays = new oogl.AttributeArrays(3);\r\n\tarrays.add2('float', [-1, 1, -1, -1, 1, -1]);\r\n\tarrays.add3('float', [0, 1, 0, 1, 0, 0, 0, 0, 1]);\r\n\tarrays.bindAndPointer();\r\n\tvar program = new oogl.AjaxProgram('test', ['in_Vertex', 'in_Color'], function () {\r\n\t\tprogram.use();\r\n\t\tarrays.drawTriangles();\r\n\t\toogl.flush();\r\n\t});\r\n});\r\n```\r\n\r\nFor further experimenting, please refer to the [OOGL API Reference](http://71104.github.com/oogl.js/doc/) and the [Demos](http://71104.github.com/oogl.js/demos/).\r\n\r\nMath stuff\r\n==========\r\n\r\nOOGL includes mutable vector and matrix classes that perfectly integrate with the provided program and shader classes; you can easily use them to exchange variables with your shaders.\r\n\r\nFor example you can specify a `vec3` uniform variable in this way:\r\n\r\n```javascript\r\nvar v = new OOGL.Vector3(x, y, z);\r\nprogram.uniformVec3('Vector', v);\r\n```\r\n\r\nSimilarly, you can specify a `mat4` uniform like this:\r\n\r\n```javascript\r\nvar m = new OOGL.Matrix3([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\nprogram.uniformMat3('Matrix', m);\r\n```\r\n\r\nOOGL provides classes to handle 2-, 3- and 4-component vectors and 2x2, 3x3 and 4x4 matrices.\r\n\r\nOOGL math classes are developed with a strong focus on performances and can be used to perform physics or other vector and matrix computations in JavaScript at maximum speed.\r\n\r\nCredits\r\n=======\r\n\r\nOOGL was created by Alberto La Rocca and is licensed under the MIT License.\r\n","name":"oogl.js","google":"UA-36961344-2","tagline":"A thin object-oriented layer above WebGL.","note":"Don't delete this file! It's used internally to help with page regeneration."}